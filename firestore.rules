rules_version = '2';

service cloud.firestore {
	match /databases/{database}/documents {
		// Only allow the two specific chat users
		function isAllowedUser() {
			return request.auth != null && (
				request.auth.uid == "DrTZw7Kv5MeGpdVbiU4lp6Kk6nF3" ||
				request.auth.uid == "EJTfm5BLcuQjgiCUMsYTVu0BJXS2"
			);
		}

		// Helper: ensure participants array contains exactly the 2 UIDs
		function validParticipants(p) {
			return p is list && p.size() == 2 &&
						 p.hasOnly(["DrTZw7Kv5MeGpdVbiU4lp6Kk6nF3", "EJTfm5BLcuQjgiCUMsYTVu0BJXS2"]);
		}

		// Conversation document
		match /conversations/{conversationId} {

			// Create conversation only once with correct participants
			allow create: if isAllowedUser() &&
										 validParticipants(request.resource.data.participants) &&
										 request.resource.data.createdAt == request.time;

			// Read conversation details
			allow read: if isAllowedUser();

			// Prevent updates/deletes to conversation doc
			allow update, delete: if false;

			// Messages subcollection
			match /messages/{messageId} {

				// Allow reading messages only for allowed users
				allow read: if isAllowedUser();

				// Allow sending a message (create only)
				// A message must be created by an allowed user, senderId must match auth.uid,
				// createdAt must be server time, and either `text` (string) OR `media_url` (string)
				// must be provided. Receiver must be one of the participants.
				allow create: if isAllowedUser() &&
											 request.resource.data.senderId == request.auth.uid &&
											 request.resource.data.createdAt == request.time &&
											 (
												 (request.resource.data.text is string && !(request.resource.data.media_url is string)) ||
												 (request.resource.data.media_url is string && !(request.resource.data.text is string))
											 ) &&
											 // ensure receiverId exists and is one of the participants
											 request.resource.data.receiverId is string &&
											 request.resource.data.receiverId in request.resource.data.participants;

				// Block edits or deletes completely
				allow update, delete: if false;
			}
		}

		// Optional: per-user profile documents to manage display name and avatar URL.
		// Path: /users/{userId}
		match /users/{userId} {
			// Allow anyone authenticated to read user profiles
			allow read: if request.auth != null;

			// Allow creating a user doc only if it's the authenticated user
			allow create: if request.auth != null && request.auth.uid == userId &&
										request.resource.data.name is string &&
										(request.resource.data.profileImageUrl is string || !('profileImageUrl' in request.resource.data));

			// Allow the authenticated user to update their own profile (name/profileImageUrl) but nothing else
			allow update: if request.auth != null && request.auth.uid == userId &&
										request.resource.data.keys().hasOnly(['name','profileImageUrl']) &&
										request.resource.data.name is string &&
										(request.resource.data.profileImageUrl is string || !('profileImageUrl' in request.resource.data));

			// No deletes allowed of user profiles from client
			allow delete: if false;
		}
	}
}
